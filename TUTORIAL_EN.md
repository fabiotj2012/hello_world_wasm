# Tutorial: "Hello, World!" with Rust and WebAssembly (WASM)

This tutorial demonstrates how to create a Rust project that compiles to both a native executable (EXE) and WebAssembly, allowing the same code to run on desktop and in the browser.

## Prerequisites

- **Rust:** Install via [rustup](https://rustup.rs/).
- **wasm-pack:** Install with `cargo install wasm-pack`.

## Step 1: Create the Project

Create a new Rust library. The name `hello_world_wasm` was used in this example.

```bash
cargo new --lib hello_world_wasm
cd hello_world_wasm
```

## Step 2: Configure `Cargo.toml`

Replace the content of your `Cargo.toml` to support both native and web compilations:

```toml
[package]
name = "hello_world_wasm"
version = "0.1.0"
edition = "2024"

# Defines crate types for dynamic and static libraries
[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
# Specific dependency for the WASM target
[target.'cfg(target_arch = "wasm32")'.dependencies]
wasm-bindgen = "0.2"

# Defines the executable for native compilation
[[bin]]
name = "hello_world_native"
path = "src/main.rs"
```

## Step 3: Write the Rust Code

We will create the shared logic (`lib.rs`) and the entry point for the native executable (`main.rs`).

**1. Shared Logic (`src/lib.rs`):**

This file contains the `greet()` function that will be used by both targets.

```rust
// Attributes for conditional compilation (WASM only)
#[cfg(target_arch = "wasm32")]
use wasm_bindgen::prelude::*;

// Exposes the `greet` function to JavaScript when compiled to WASM
#[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
pub fn greet() -> String {
    "Hello, world!".to_string()
}
```

**2. Native Executable (`src/main.rs`):**

Create this new file. It simply calls the `greet()` function from our library.

```rust
// Imports the function from our crate (library)
use hello_world_wasm::greet;

fn main() {
    println!("{}", greet());
}
```

## Step 4: Create the Web Interface

**1. HTML Page (`src/index.html`):**

Create the file that will serve as the page for your web application.

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Hello, Rust + WASM!</title>
  </head>
  <body>
    <!-- The `type="module"` is crucial for using `import` in JavaScript -->
    <script type="module" src="./bootstrap.js"></script>
  </body>
</html>
```

**2. JavaScript Module (`src/bootstrap.js`):**

Create the file that will load and execute your WASM code.

```javascript
// Imports the initialization function and the `greet` function from the WASM package
// The path `../pkg/` points to the folder generated by wasm-pack
import init, { greet } from "../pkg/hello_world_wasm.js";

// Initializes the WASM module and, if successful, calls the `greet` function
init()
  .then(() => {
    alert(greet());
  })
  .catch(console.error);
```

## Step 5: Compile

**1. Compile to WebAssembly:**

This command compiles your Rust code to WASM and prepares it in a package within the `pkg/` directory.

```bash
wasm-pack build --target web
```

**2. Compile to Native Executable:**

```bash
cargo build
```

## Step 6: Run the Application

**Native Executable:**

```bash
cargo run
# Expected output: Hello, world!
```

**Web Application:**

To view in the browser, you need a local server.
1.  Navigate to the `hello_world_wasm` directory.
2.  Start a server from the project root. If you have VS Code, the "Live Server" extension works well (right-click on `src/index.html` and select "Open with Live Server").
3.  Open `index.html` through the local server. An alert with "Hello, world!" should appear.

## File Structure

### `src` Folder - Source Code

-   `lib.rs`: The heart of your Rust library. Contains the main logic (`fn greet()`) that is shared between the native executable and WebAssembly. Conditional compilation (`#[cfg(...)]`) ensures that `wasm-bindgen` specific code is only used for the web target.
-   `main.rs`: The entry point for native compilation (EXE). It acts as a standard Rust program that imports and uses the functionality of your library (`lib.rs`).
-   `index.html`: The web page that the end-user will open in the browser. Its sole function is to load the JavaScript script that initializes WASM.
-   `bootstrap.js`: The "launcher" for your WebAssembly. It imports the WASM module, initializes it, and calls the exported Rust functions (like `greet()`).

### `pkg` Folder - WebAssembly Package

This folder is **automatically generated** by `wasm-pack`. It contains everything needed to use your Rust code in the browser.

-   `hello_world_wasm_bg.wasm`: Your Rust code compiled into the WebAssembly binary format. This is the file that the browser actually executes.
-   `hello_world_wasm.js`: The JavaScript "glue" generated by `wasm-bindgen`. It creates a bridge between JavaScript and your WASM code, allowing you to call Rust functions (like `greet()`) directly from your JS code. It also manages memory and other complex interactions.
-   `hello_world_wasm.d.ts`: Type definition file for TypeScript. Provides autocompletion and type checking if you are using TypeScript in your web project.
-   `package.json`: A manifest file that describes this package, listing the files that compose it. It is useful for integration with modern JavaScript ecosystems.